

Core=====================================================================================================================

(DataStruct)리스트 노드 복사, 이동 연결 문제-------------------------------------------------------------------------------

리스트 노드들의 복사, 이동 생성자(+연산자 재정의)를 단순 복사, 이동으로 구현했는데 그럴 경우 연결된 노드들은 새로운 노드와 연결되지 않습니다.
만약 새로운 객체에서 기존 객체와 연결된 노드들에게 본인을 연결하게 한다면 원본 노드와의 연결을 잃어버리게 됩니다. 이동 생성자는 의미상 원본 객체가 무효화 되는것이기에 문제가 없으나 복사의 경우는 문제입니다.

방안1. 복사, 이동 기능을 단순하게 값을 복사하는 선에서 멈춥니다. 연결과 관련된 문제는 사용하는 측에서 알아서 처리하게끔 놔둡니다.
방안2. 복사 기능 삭제, 이동 기능은 주변 노드들이 새로운 노드를 연결하게 합니다. 원본 노드는 무효화 됩니다.
방안3. 복사, 이동 전부 삭제. 복사, 이동이 일어났을 때 어떻게 될지 머리속에 그려보아야 해서 복잡합니다. 차라리 기능을 뺌으로서 난해하지 않게 만듭니다. 당연히 생성자, 연산자 재정의가 없어도 복사, 이동코드는 작성 가능합니다.

결론 => 방안3. 자료구조들은 컨테이너를 제외하곤 최하위 수준의 기능을 제공하는 것을 목적으로 하고 있습니다. 이 자료구조들을 활용해 원하는 자료구조를 구성하는 것입니다. 최대한 단순하게 사용할 수 있는 방안을 선택했습니다.

-------------------------------------------------------------------------------------------------------------------------

(DataStruct)리스트 노드 탐색 함수에 람다를 넘겨줄 때 인자추론이 안되는 문제---------------------------------------------

두번째 파라미터로 람다를 넘겨줄 때 std::function<bool(const Type&)>이 생성되며 람다객체를 생성자로 받는 일이 일어나는데 근본적으로는 람다와 function은 다른 클래스입니다.
순서상 function의 타입이 정해져야 람다를 받을 수 있는지 없는지(=적합한 생성자가 있는지) 알 수 있는데 그러기 위해선 타입이 추론되어야 합니다. 하지만 람다와 function은 결국은 다른 타입이므로 추론의 대상이 될 수 없습니다.
이러한 원리로 람다로 std::function<bool(const Type&)>의 Type을 추론하게 할 수 없는게 아닐까 생각합니다.

람다를 먼저 적합한 function으로 받아주고 그 function을 넘겨주면 추론이 됩니다. 아니면 템플릿 파라미터를 명시하면 됩니다.


-------------------------------------------------------------------------------------------------------------------------

=========================================================================================================================